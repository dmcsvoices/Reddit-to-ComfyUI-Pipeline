#!/usr/bin/env python3
"""
Standalone ComfyUI Prompt Executor
Execute ComfyUI prompts from extracted markdown files
"""

import os
import sys
import json
import time
from pathlib import Path
import argparse

def execute_comfyui_prompt_standalone(prompt_text, output_dir="./poc_output/designs", trend_id=None):
    """
    Execute a ComfyUI prompt using the workflow module
    This function is designed to run in the ComfyUI environment
    """
    try:
        # Try to import the ComfyUI workflow
        import tshirtPOC_768x1024 as workflow_module
        print("‚úÖ ComfyUI workflow module loaded")
    except ImportError as e:
        print(f"‚ùå Failed to import ComfyUI workflow: {e}")
        print("üí° Make sure you're running this from the ComfyUI environment")
        return {
            "success": False,
            "error": f"ComfyUI workflow not available: {e}"
        }

    # Ensure output directory exists
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)

    # Generate unique filename
    timestamp = int(time.time())
    trend_suffix = f"_{trend_id}" if trend_id else ""
    output_filename = f"tshirt_design{trend_suffix}_{timestamp}.png"
    full_output_path = output_path / output_filename

    try:
        print(f"üé® Executing ComfyUI workflow...")
        print(f"   Prompt: {prompt_text[:100]}...")
        print(f"   Output: {output_filename}")

        # Execute the workflow with the prompt
        result = workflow_module.main(
            text4=prompt_text,  # Main prompt
            text5="",  # Negative prompt (empty)
            width6=768,
            height7=1024,
            steps13=20,
            seed12=timestamp,  # Use timestamp as seed for uniqueness
            guidance11=4,
            cfg14=1,
            sampler_name15='dpmpp_2m_sde',
            scheduler16='beta',
            denoise17=1,
            filename_prefix18=f"POC{trend_suffix}_{timestamp}",
            output=str(full_output_path),
            queue_size=1
        )

        if result and 'images' in result:
            print(f"‚úÖ ComfyUI generation successful: {output_filename}")
            return {
                "success": True,
                "output_path": str(full_output_path),
                "trend_id": trend_id,
                "prompt": prompt_text,
                "result_data": result
            }
        else:
            print(f"‚ùå ComfyUI generation failed: No images in result")
            return {
                "success": False,
                "error": "No images generated by ComfyUI workflow"
            }

    except Exception as e:
        print(f"‚ùå ComfyUI workflow execution error: {str(e)}")
        return {
            "success": False,
            "error": f"Workflow execution failed: {str(e)}"
        }

def extract_prompts_from_markdown(markdown_dir):
    """Extract ComfyUI prompts from markdown files"""
    import re

    prompt_dir = Path(markdown_dir)
    if not prompt_dir.exists():
        print(f"‚ùå Prompt directory not found: {prompt_dir}")
        return []

    markdown_files = list(prompt_dir.glob("*.md"))
    if not markdown_files:
        print(f"‚ùå No markdown files found in {prompt_dir}")
        return []

    print(f"üìÑ Found {len(markdown_files)} prompt files")

    extracted_prompts = []
    for md_file in markdown_files:
        try:
            with open(md_file, 'r', encoding='utf-8') as f:
                content = f.read()

            # Extract ComfyUI prompt
            pattern = r'## ComfyUI Prompt\s*\n\s*```\s*\n(.*?)\n\s*```'
            match = re.search(pattern, content, re.DOTALL)

            if match:
                prompt = match.group(1).strip()

                # Extract trend ID from filename or content
                trend_id_match = re.search(r'- \*\*Reddit ID\*\*: (.+)', content)
                trend_id = trend_id_match.group(1) if trend_id_match else md_file.stem

                extracted_prompts.append({
                    'file': md_file.name,
                    'prompt': prompt,
                    'trend_id': trend_id
                })
                print(f"‚úÖ Extracted prompt from: {md_file.name}")
            else:
                print(f"‚ö†Ô∏è  No ComfyUI prompt found in: {md_file.name}")

        except Exception as e:
            print(f"‚ùå Error reading {md_file}: {e}")

    return extracted_prompts

def main():
    parser = argparse.ArgumentParser(description='Execute ComfyUI prompts from markdown files')
    parser.add_argument('--prompt-dir', '-p', default='./poc_output/prompts',
                       help='Directory containing prompt markdown files')
    parser.add_argument('--output-dir', '-o', default='./poc_output/designs',
                       help='Output directory for generated images')
    parser.add_argument('--single-prompt', '-s', help='Execute a single prompt text directly')
    parser.add_argument('--trend-id', '-t', help='Trend ID for single prompt execution')
    parser.add_argument('--latest-only', '-l', action='store_true',
                       help='Process only the latest prompt file')
    parser.add_argument('--dry-run', '-d', action='store_true',
                       help='Show what would be executed without running')

    args = parser.parse_args()

    print("üé® ComfyUI Standalone Prompt Executor")
    print("=" * 50)

    # Check if we're in the right environment
    try:
        import comfy
        print("‚úÖ ComfyUI environment detected")
    except ImportError:
        print("‚ö†Ô∏è  ComfyUI modules not found in current environment")
        print("üí° Make sure you're running this from the ComfyUI installation directory")

    if args.single_prompt:
        # Execute single prompt
        print(f"üîß Executing single prompt...")
        if args.dry_run:
            print(f"[DRY RUN] Would execute: {args.single_prompt[:100]}...")
        else:
            result = execute_comfyui_prompt_standalone(
                args.single_prompt,
                args.output_dir,
                args.trend_id or "manual"
            )
            if result["success"]:
                print(f"‚úÖ Generated: {result['output_path']}")
            else:
                print(f"‚ùå Failed: {result['error']}")
        return

    # Extract prompts from markdown files
    prompts = extract_prompts_from_markdown(args.prompt_dir)

    if not prompts:
        print("‚ùå No prompts found to execute")
        return

    if args.latest_only:
        # Sort by file modification time and take the latest
        prompt_files = [(Path(args.prompt_dir) / p['file']) for p in prompts]
        latest_file = max(prompt_files, key=lambda x: x.stat().st_mtime)
        prompts = [p for p in prompts if p['file'] == latest_file.name]
        print(f"üìÑ Processing latest file only: {latest_file.name}")

    print(f"\nüöÄ Processing {len(prompts)} prompts...")

    results = []
    for i, prompt_data in enumerate(prompts, 1):
        print(f"\nüñºÔ∏è  [{i}/{len(prompts)}] Processing: {prompt_data['file']}")

        if args.dry_run:
            print(f"[DRY RUN] Would execute prompt for trend: {prompt_data['trend_id']}")
            print(f"[DRY RUN] Prompt: {prompt_data['prompt'][:100]}...")
            results.append({"success": True, "dry_run": True})
            continue

        result = execute_comfyui_prompt_standalone(
            prompt_data['prompt'],
            args.output_dir,
            prompt_data['trend_id']
        )

        if result["success"]:
            print(f"‚úÖ Generated: {result['output_path']}")
        else:
            print(f"‚ùå Failed: {result['error']}")

        results.append(result)

        # Small delay between generations to avoid overwhelming the system
        time.sleep(2)

    # Summary
    successful = [r for r in results if r.get("success", False)]
    print(f"\nüéâ Execution Complete!")
    print(f"‚úÖ Successful: {len(successful)}/{len(results)}")

    if successful and not args.dry_run:
        print("\nüìÅ Generated files:")
        for result in successful:
            if not result.get("dry_run"):
                print(f"  {result['output_path']}")

    print(f"\nüìÅ Output directory: {args.output_dir}")

if __name__ == "__main__":
    main()